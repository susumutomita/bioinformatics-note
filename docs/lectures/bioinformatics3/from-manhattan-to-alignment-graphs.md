---
sidebar_position: 5
title: マンハッタンからアライメントグラフへ：最長経路問題の一般化
---

# マンハッタンからアライメントグラフへ：最長経路問題の一般化

## 🎯 まず、この講義で何を学ぶのか

最終ゴール：規則正しいマンハッタングリッドから、任意のアライメントグラフでの最長経路を見つける方法を習得し、どんな配列比較問題も解けるようになります。

でも、ちょっと待ってください。そもそも...

## 🤔 ステップ0：なぜマンハッタンでは不十分なの？

### 現実は格子じゃない

```
マンハッタングリッド：
■ → → → □
↓   ↓   ↓
→ → → ↓
↓   ↓   ↓

きれいな格子状
すべて規則的

でも現実の配列比較は...
```

### 実際のアライメントグラフ

```
現実のグラフ：
    ○
   ╱│╲
  ○ ○ ○
  │╲│╱│
  ○ ○ ○
   ╲│╱
    ○

複雑な接続
不規則な構造
```

### なぜ複雑になるの？

```
理由：
1. 挿入・欠失の可変コスト
2. 特殊な一致ボーナス
3. ギャップペナルティ
4. 生物学的制約

→ 任意のグラフで解く必要がある！
```

## 📐 ステップ1：任意のグラフでの最長経路

### 1-1. 問題の一般化

```
マンハッタン観光：
- グリッド構造のみ
- 東か南のみ移動可能
- すべてのノードが格子点

一般的なグラフ：
- 任意の構造
- 任意の方向へ移動可能
- ノードは任意の位置
```

### 1-2. 具体例で考えよう

```python
# グラフの例
#     A
#    /|\
#   B C D
#    \|/
#     E

# Aから各ノードへの経路
到達方法 = {
    "B": ["A→B"],           # 1通り
    "C": ["A→C"],           # 1通り
    "D": ["A→D"],           # 1通り
    "E": ["A→B→E", "A→C→E", "A→D→E", "???"]  # 4通り？
}

# どれを選べばいい？
```

### 1-3. 最長経路の選択

```
Eに到達する4つの経路：
1. A→B→E: 長さ = 3 + 7 = 10
2. A→C→E: 長さ = 2 + 5 = 7
3. A→D→E: 長さ = 1 + 8 = 9
4. 別の経路: 長さ = ?

最適解：経路1を選択（長さ10）
```

## 🔄 ステップ2：動的計画法の一般化

### 2-1. 再帰的定義

```
S(v) = ソースからノードvまでの最長経路の長さ

計算方法：
S(v) = max{S(u) + weight(u→v)}
      （uはvのすべての先行ノード）

つまり：
「vに到達する最良の方法は、
vの前のノードへの最良の経路 + そこからvへの重み」
```

### 2-2. アライメントグラフでの再帰

```python
def longest_path_to(i, j):
    """位置(i,j)までの最長経路"""

    # 3つの可能性
    choices = []

    # 垂直移動（挿入）
    if i > 0:
        choices.append(S[i-1][j] + vertical_weight)

    # 水平移動（欠失）
    if j > 0:
        choices.append(S[i][j-1] + horizontal_weight)

    # 斜め移動（マッチ/ミスマッチ）
    if i > 0 and j > 0:
        choices.append(S[i-1][j-1] + diagonal_weight)

    return max(choices)
```

### 2-3. 最長共通部分列（LCS）の特殊ケース

```
LCSの場合：
- マッチするエッジ：重み = 1
- その他のエッジ：重み = 0

再帰式：
S(i,j) = max{
    S(i-1, j) + 0,        # 垂直
    S(i, j-1) + 0,        # 水平
    S(i-1, j-1) + match   # 斜め（matchは0か1）
}
```

## 🎨 ステップ3：バックトラッキング

### 3-1. 経路の記録

```
各ノードで記録すること：
1. 最長経路の長さ（スコア）
2. どこから来たか（バックトラッキングポインタ）

例：
ノード(3,4)：
- スコア: 15
- 来た方向: ↖（斜め）
```

### 3-2. バックトラッキングの実装

```python
def backtrack(i, j):
    """最適経路を逆向きにたどる"""
    path = []

    while i > 0 or j > 0:
        if pointer[i][j] == "↖":
            path.append("match")
            i -= 1
            j -= 1
        elif pointer[i][j] == "↑":
            path.append("insert")
            i -= 1
        else:  # "←"
            path.append("delete")
            j -= 1

    return reversed(path)
```

### 3-3. LCSの実例

```
配列1: ATCG
配列2: ACG

バックトラッキング結果：
■ → → → □
↓ ↖ → ↖ ↓
↓ ↑ ↖ ← ↓
↓ ↑ ↑ ↖ ↓

最適経路：ACG（青い矢印をたどる）
```

## 😱 ステップ4：循環の罠

### 4-1. 問題の発見

```
循環があるグラフ：
    A
   ↙ ↘
  B → C
   ↖ ↙
    D

Bのスコアを計算するには...
→ Dのスコアが必要
→ でもDの計算にはCが必要
→ Cの計算にはBが必要
→ 無限ループ！
```

### 4-2. なぜ循環が問題か

```
循環の問題：
1. スコアが無限大になる可能性
   （同じ経路を何度も通れる）

2. 計算順序が決められない
   （どこから始めればいい？）

3. 動的計画法が使えない
   （部分問題が独立でない）
```

### 4-3. 解決策：DAG

```
DAG（有向非巡回グラフ）：
Directed Acyclic Graph

条件：
- 有向グラフ
- 循環（サイクル）がない

なぜDAGなら解ける？
→ トポロジカル順序が存在する！
```

## 🦇 ステップ5：トポロジカル順序

### 5-1. バットマンの朝の身支度

```
バットマンの着替え順序：
（これもDAGの例！）

パンツ → ズボン → ベルト
  ↓        ↓        ↓
シャツ → ネクタイ → ジャケット
  ↓        ↓        ↓
靴下  →   靴   →  マント

すべてのエッジが左から右へ
```

### 5-2. トポロジカル順序とは

```
定義：
「グラフのすべてのエッジが
左から右に向かうようなノードの並び」

重要な性質：
- すべてのDAGはトポロジカル順序を持つ
- 順序は一意とは限らない
- 循環があると不可能
```

### 5-3. マンハッタングリッドの場合

```
マンハッタンのトポロジカル順序（例）：

順序1：行優先
(0,0)→(0,1)→(0,2)→(1,0)→(1,1)→...

順序2：列優先
(0,0)→(1,0)→(2,0)→(0,1)→(1,1)→...

どちらも正しい！
```

## 🚀 ステップ6：アルゴリズムの完成

### 6-1. 最長経路アルゴリズム

```python
def longest_path_in_dag(graph):
    """DAGでの最長経路を求める"""

    # ステップ1：トポロジカル順序を求める
    order = topological_sort(graph)

    # ステップ2：順序通りに更新
    scores = {}
    for node in order:
        if node == source:
            scores[node] = 0
        else:
            # すべての先行ノードから最大値を選択
            scores[node] = max(
                scores[pred] + weight(pred, node)
                for pred in predecessors(node)
            )

    return scores[sink]
```

### 6-2. 計算量の分析

```
時間計算量：O(|E|)
- E：グラフのエッジ数
- 各エッジを1回だけ見る

空間計算量：O(|V|)
- V：グラフのノード数
- 各ノードのスコアを保存

効率的！
```

### 6-3. 実装のポイント

```
重要な実装詳細：

1. トポロジカル順序の計算
   - DFSベース：O(V+E)
   - Kahnのアルゴリズム：O(V+E)

2. 先行ノードの管理
   - 隣接リストで効率化
   - エッジの重みも同時に保存

3. バックトラッキング
   - ポインタを同時に更新
   - メモリ効率を考慮
```

## 🎯 ステップ7：配列アラインメントへの応用

### 7-1. アライメントグラフの構造

```
配列1: ATG
配列2: ACG

アライメントグラフ：
    A   T   G
A   ○───○───○
    │ ╲ │ ╲ │
C   ○───○───○
    │ ╲ │ ╲ │
G   ○───○───○

すべてDAG！（循環なし）
```

### 7-2. 重みの設定

```python
# 実用的な重み設定
def edge_weight(i, j, direction):
    if direction == "diagonal":
        if seq1[i] == seq2[j]:
            return +1  # マッチボーナス
        else:
            return -1  # ミスマッチペナルティ
    else:
        return -2  # ギャップペナルティ
```

### 7-3. 生物学的意味

```
重みの生物学的解釈：

マッチ (+1)：
→ 進化的に保存された領域

ミスマッチ (-1)：
→ 点突然変異

ギャップ (-2)：
→ 挿入・欠失変異（より稀）
```

## 💡 ステップ8：まとめ

### レベル1：基礎理解

```
学んだこと：
1. マンハッタングリッド → 任意のグラフ
2. 動的計画法の一般化
3. DAGの必要性
```

### レベル2：応用理解

```
できるようになったこと：
1. 任意のアライメントグラフで最長経路
2. バックトラッキングで最適解を復元
3. トポロジカル順序の活用
```

### レベル3：実装理解

```python
# 完全なアルゴリズム
def sequence_alignment(seq1, seq2):
    # 1. アライメントグラフを構築
    graph = build_alignment_graph(seq1, seq2)

    # 2. トポロジカル順序で処理
    for i in range(len(seq1)+1):
        for j in range(len(seq2)+1):
            update_score(i, j)

    # 3. バックトラッキング
    return backtrack_path()
```

## 🚀 次回予告

次回は「編集距離とアラインメントスコア」について学びます。なぜある変異は他の変異より起こりやすいのか？PAM行列とBLOSUM行列の秘密を解き明かします！

---

_配列比較の数学的美しさを、一緒に探求していきましょう！_
