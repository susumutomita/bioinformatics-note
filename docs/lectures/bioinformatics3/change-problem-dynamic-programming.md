---
sidebar_position: 5
title: 両替問題から学ぶ動的計画法の威力
---

# 両替問題から学ぶ動的計画法の威力

## 🎯 まず、この講義で何を学ぶのか

最終ゴール：一見簡単そうな「お釣りを返す」問題から、アルゴリズムの世界で最も重要な手法の一つ「動的計画法」を理解し、なぜこれが配列比較にも使えるのかを発見します。

でも、ちょっと待ってください。そもそも...

## 🤔 ステップ0：なぜお釣りの話？

### スーパーでの日常風景

```
状況：
本を買って40セントのお釣り

レジ係の選択：
- 25セント硬貨 × 1枚
- 10セント硬貨 × 1枚
- 5セント硬貨 × 1枚
= 合計3枚

でも、これが最善？
```

### 隠れた数学的問題

```
両替問題（Change Problem）：
「与えられた金額を、最小枚数のコインで返す」

簡単そう...？
実は奥が深い！
```

## 💰 ステップ1：グリーディ戦略の罠

### 1-1. 世界中のレジ係の戦略

```python
def greedy_change(amount, coins):
    """レジ係が使う戦略"""
    result = []
    for coin in sorted(coins, reverse=True):
        while amount >= coin:
            result.append(coin)
            amount -= coin
    return result

# アメリカの場合
us_coins = [25, 10, 5, 1]
greedy_change(40, us_coins)  # [25, 10, 5] = 3枚
```

### 1-2. これで完璧...？

```
アメリカ：うまくいく！
日本：うまくいく！

じゃあ、これで解決？
```

### 1-3. タンザニアの衝撃

```
タンザニアの硬貨：
[25, 20, 10, 5, 1]  # 20セント硬貨がある！

グリーディ戦略：
40 → 25 + 10 + 5 = 3枚

でも実は：
40 → 20 + 20 = 2枚で済む！

グリーディは失敗した...
```

## 😱 ステップ2：なぜグリーディが失敗するか

### 2-1. グリーディの本質

```
グリーディ = 「目先の最善」

考え方：
「今、一番大きいコインを使えば、
 残りの金額が小さくなるから良いはず」

でも...
```

### 2-2. 局所最適 ≠ 大域最適

```
例：もっと極端なケース
コイン：[6, 5, 1]
金額：9セント

グリーディ：
9 → 6 + 1 + 1 + 1 = 4枚

最適解：
9 → 5 + 1 + 1 + 1 + 1 = 5枚？
違う！
9 → 6 + 1 + 1 + 1 = 4枚？
いや、実は...
9 → 3 + 3 + 3...あれ？3セント硬貨はない

正解：
9 → 5 + 1 + 1 + 1 + 1 = 5枚？
いや、6 + 1 + 1 + 1 = 4枚
```

### 2-3. 問題の難しさ

```
なぜ難しい？
→ 全ての組み合わせを試さないと
  本当の最適解が分からない

でも組み合わせは膨大...
```

## 🔄 ステップ3：再帰的アプローチ

### 3-1. 問題を分解する

```
9セントを両替する
= 以下の最小値：
  - (8セントの最適解) + 1セント硬貨
  - (4セントの最適解) + 5セント硬貨
  - (3セントの最適解) + 6セント硬貨

つまり：
大きな問題 = 小さな問題 + 1枚のコイン
```

### 3-2. 再帰的に考える

```python
def recursive_change(amount, coins):
    """再帰的アプローチ"""
    if amount == 0:
        return 0

    min_coins = float('inf')
    for coin in coins:
        if amount >= coin:
            # 残りの金額を再帰的に解く
            num_coins = recursive_change(amount - coin, coins)
            min_coins = min(min_coins, num_coins + 1)

    return min_coins
```

### 3-3. これで解決...？

```
正しい答えは出る！

でも...
```

## 😰 ステップ4：再帰の恐ろしい罠

### 4-1. 同じ計算の繰り返し

```
76セントを計算するとき：

76
├─ 75 (1セント引く)
│  ├─ 74
│  ├─ 70 → ★69を計算
│  └─ 69
├─ 71 (5セント引く)
│  ├─ 70 → ★69を計算
│  ├─ 66
│  └─ 65
└─ 51 (25セント引く)
   └─ ... → ★69を計算

69セントを何回計算する？
→ 6回以上！
```

### 4-2. 指数的爆発

```
30セントの計算回数：
なんと数兆回！

76セントなら：
宇宙の年齢より長い時間が必要...

このままでは使えない！
```

### 4-3. なぜこんなことに？

```
原因：
同じ部分問題を何度も解いている

69セントの最適解は一度計算すれば十分なのに
毎回最初から計算し直している

無駄だらけ！
```

## 💡 ステップ5：動的計画法の誕生

### 5-1. 発想の転換

```
従来：大→小（トップダウン）
「76セントを解くには75, 71, 51が必要...」

新発想：小→大（ボトムアップ）
「0セント、1セント、2セント...順番に解いていく」
```

### 5-2. 表を作ろう

```
金額：  0  1  2  3  4  5  6  7  8  9
最小枚数：0  1  2  3  4  1  1  2  3  2

どうやって埋める？

5セントの場合：
- (0セント) + 5セント硬貨 = 0 + 1 = 1枚
- (4セント) + 1セント硬貨 = 4 + 1 = 5枚
→ 最小は1枚！
```

### 5-3. 魔法のような効率化

```python
def dynamic_change(amount, coins):
    """動的計画法による解法"""
    # 表を初期化
    min_coins = [0] + [float('inf')] * amount

    # 小さい金額から順に計算
    for m in range(1, amount + 1):
        for coin in coins:
            if m >= coin:
                min_coins[m] = min(
                    min_coins[m],
                    min_coins[m - coin] + 1
                )

    return min_coins[amount]
```

## 🎨 ステップ6：なぜこれが革命的？

### 6-1. 計算回数の劇的削減

```
再帰的アプローチ：
76セントで数兆回の計算

動的計画法：
76 × コインの種類数 = 約380回

数兆 → 380
これが動的計画法の威力！
```

### 6-2. 重複を排除

```
各金額の最適解を一度だけ計算
→ 表に保存
→ 必要なときは表を見るだけ

「メモ化」という技術
```

### 6-3. 保証される最適性

```
グリーディ：速いけど間違うことがある
動的計画法：必ず最適解を見つける

速さと正確さの両立！
```

## 🔗 ステップ7：配列比較への応用

### 7-1. 共通する構造

```
両替問題：
「大きな金額 = 小さな金額 + 1枚」

配列比較：
「長い配列 = 短い配列 + 1文字」

同じ再帰構造！
```

### 7-2. マンハッタンとの関係

```
両替問題の表：
金額0 → 金額1 → 金額2 → ...

マンハッタン：
(0,0) → (0,1) → (0,2) → ...
   ↓      ↓        ↓
(1,0) → (1,1) → (1,2) → ...

どちらも表を埋めていく！
```

### 7-3. 統一的理解

```python
def general_dp_structure():
    """動的計画法の一般構造"""
    # 1. 表を初期化
    table = initialize()

    # 2. 小さい問題から解く
    for smaller_problem in sorted_problems:
        # 3. より小さい問題の解を使う
        for choice in possible_choices:
            update_table(smaller_problem, choice)

    # 4. 最終的な答えを返す
    return table[final_problem]
```

## 🎭 ステップ8：リチャード・ベルマンの秘密

### 8-1. 名前の由来

```
1950年代、空軍プロジェクト
数学者ベルマンの悩み：

「数学をやってると言ったら
 国防長官に怒られる...」

解決策：
「動的計画法」という名前をつけた
（プログラミングは入ってない！）
```

### 8-2. 皮肉な運命

```
当時：「実用的じゃない」と思われた
今日：最も重要なアルゴリズム手法の一つ

応用分野：
- AI（強化学習）
- 金融（ポートフォリオ最適化）
- 生物学（配列解析）
- 物流（経路最適化）
```

### 8-3. 教訓

```
「役に立たない」と思われた研究が
世界を変えることがある

基礎研究の重要性！
```

## 📝 まとめ：今日学んだこと

### レベル1：基礎理解

```
- 両替問題とグリーディの失敗
- 再帰的アプローチと計算爆発
- 動的計画法による解決
```

### レベル2：深い理解

```
- ボトムアップ vs トップダウン
- メモ化による効率化
- 部分問題の最適性
```

### レベル3：統合的理解

```
- 配列比較との共通構造
- 動的計画法の一般原理
- アルゴリズム設計の思想
```

## 🎯 覚えておくべきこと

```python
def dynamic_programming_wisdom():
    """動的計画法の本質"""

    原則 = {
        "分割": "大きな問題を小さな問題に",
        "記憶": "一度解いた問題は覚えておく",
        "構築": "小さな解から大きな解を作る"
    }

    return "賢く怠けることが、最高の効率を生む"
```

## 🚀 次回予告

次回は「動的計画法による配列アラインメント」を学びます。両替問題で学んだ技術を使って、実際にDNA配列を比較するプログラムを作ります！

---

お釣りを返すという日常の問題が、生命の神秘を解く鍵になるなんて！
