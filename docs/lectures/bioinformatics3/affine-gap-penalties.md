---
sidebar_position: 7
title: ã‚¢ãƒ•ã‚£ãƒ³ã‚®ãƒ£ãƒƒãƒ—ãƒšãƒŠãƒ«ãƒ†ã‚£ï¼šã‚ˆã‚Šç¾å®Ÿçš„ãªé…åˆ—ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆ
---

# ã‚¢ãƒ•ã‚£ãƒ³ã‚®ãƒ£ãƒƒãƒ—ãƒšãƒŠãƒ«ãƒ†ã‚£ï¼šã‚ˆã‚Šç¾å®Ÿçš„ãªé…åˆ—ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆ

## ğŸ¯ ã¾ãšã€ã“ã®è¬›ç¾©ã§ä½•ã‚’å­¦ã¶ã®ã‹

æœ€çµ‚ã‚´ãƒ¼ãƒ«ï¼šãªãœé€£ç¶šã—ãŸã‚®ãƒ£ãƒƒãƒ—ã¯å˜ä¸€ã®ã‚®ãƒ£ãƒƒãƒ—ã‚ˆã‚Šèµ·ã“ã‚Šã‚„ã™ã„ã®ã‹ã‚’ç†è§£ã—ã€ç”Ÿç‰©å­¦çš„ã«ç¾å®Ÿçš„ãªã‚®ãƒ£ãƒƒãƒ—ãƒšãƒŠãƒ«ãƒ†ã‚£ãƒ¢ãƒ‡ãƒ«ã‚’å®Ÿè£…ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

ã§ã‚‚ã€ã¡ã‚‡ã£ã¨å¾…ã£ã¦ãã ã•ã„ã€‚ãã‚‚ãã‚‚..ã€‚

## ğŸ¤” ã‚¹ãƒ†ãƒƒãƒ—0ï¼šãªãœå›ºå®šãƒšãƒŠãƒ«ãƒ†ã‚£ã§ã¯ä¸ååˆ†ãªã®ï¼Ÿ

### ç¾å®Ÿã®ç”Ÿç‰©å­¦çš„ã‚¤ãƒ™ãƒ³ãƒˆ

```
å˜ç´”ãªãƒ¢ãƒ‡ãƒ«ï¼š
å„ã‚¤ãƒ³ãƒ‡ãƒ« = -2ãƒšãƒŠãƒ«ãƒ†ã‚£
5å€‹ã®é€£ç¶šã‚¤ãƒ³ãƒ‡ãƒ« = -10ãƒšãƒŠãƒ«ãƒ†ã‚£

ã§ã‚‚ç¾å®Ÿã¯...
```

### å®Ÿéš›ã®é€²åŒ–ã‚¤ãƒ™ãƒ³ãƒˆ

```python
# ãƒŠã‚¤ãƒ¼ãƒ–ãªãƒšãƒŠãƒ«ãƒ†ã‚£
def naive_gap_penalty(gap_length):
    return gap_length * fixed_penalty  # ä¾‹: 5 * (-2) = -10

# å•é¡Œï¼š5å€‹ã®ç‹¬ç«‹ã—ãŸå¤‰ç•°ã‚¤ãƒ™ãƒ³ãƒˆï¼Ÿ
# ç¾å®Ÿï¼šãŠãã‚‰ã1å›ã®å¤§ããªæŒ¿å…¥/å‰Šé™¤ã‚¤ãƒ™ãƒ³ãƒˆï¼
```

### ç”Ÿç‰©å­¦çš„æ ¹æ‹ 

```
é€£ç¶šã—ãŸã‚®ãƒ£ãƒƒãƒ—ãŒèµ·ã“ã‚‹ç†ç”±ï¼š

1. DNAãƒãƒªãƒ¡ãƒ©ãƒ¼ã‚¼ã®ã‚¹ãƒªãƒƒãƒšãƒ¼ã‚¸
   â†’ ä¸€åº¦ã«è¤‡æ•°å¡©åŸºã®æŒ¿å…¥/å‰Šé™¤

2. ãƒˆãƒ©ãƒ³ã‚¹ãƒã‚¾ãƒ³ã®æŒ¿å…¥
   â†’ æ•°ç™¾å¡©åŸºãŒä¸€åº¦ã«æŒ¿å…¥

3. çµ„æ›ãˆã‚¨ãƒ©ãƒ¼
   â†’ å¤§ããªé ˜åŸŸã®æ¬ å¤±

çµè«–ï¼šé€£ç¶šã‚®ãƒ£ãƒƒãƒ— = å˜ä¸€ã‚¤ãƒ™ãƒ³ãƒˆ
```

## ğŸ“ ã‚¹ãƒ†ãƒƒãƒ—1ï¼šã‚¢ãƒ•ã‚£ãƒ³ã‚®ãƒ£ãƒƒãƒ—ãƒšãƒŠãƒ«ãƒ†ã‚£ã®å°å…¥

### 1-1. åŸºæœ¬çš„ãªè€ƒãˆæ–¹

```
æ–°ã—ã„ãƒšãƒŠãƒ«ãƒ†ã‚£ãƒ¢ãƒ‡ãƒ«ï¼š
- ã‚®ãƒ£ãƒƒãƒ—é–‹å§‹ãƒšãƒŠãƒ«ãƒ†ã‚£ï¼šÏƒï¼ˆå¤§ãã„ï¼‰
- ã‚®ãƒ£ãƒƒãƒ—æ‹¡å¼µãƒšãƒŠãƒ«ãƒ†ã‚£ï¼šÎµï¼ˆå°ã•ã„ï¼‰

é€šå¸¸ï¼šÏƒ > Îµ

ç†ç”±ï¼š
æœ€åˆã®å¤‰ç•° = é›£ã—ã„ï¼ˆå¤§ããªãƒšãƒŠãƒ«ãƒ†ã‚£ï¼‰
ç¶™ç¶š = æ¯”è¼ƒçš„ç°¡å˜ï¼ˆå°ã•ãªãƒšãƒŠãƒ«ãƒ†ã‚£ï¼‰
```

### 1-2. æ•°å¼ã§ã®è¡¨ç¾

```python
def affine_gap_penalty(gap_length):
    """ã‚¢ãƒ•ã‚£ãƒ³ã‚®ãƒ£ãƒƒãƒ—ãƒšãƒŠãƒ«ãƒ†ã‚£ã®è¨ˆç®—"""
    if gap_length == 0:
        return 0
    else:
        # é–‹å§‹ãƒšãƒŠãƒ«ãƒ†ã‚£ + æ‹¡å¼µãƒšãƒŠãƒ«ãƒ†ã‚£Ã—(é•·ã•-1)
        return -Ïƒ - Îµ * (gap_length - 1)

# ä¾‹ï¼šÏƒ=10, Îµ=1
# é•·ã•1ã®ã‚®ãƒ£ãƒƒãƒ—: -10
# é•·ã•2ã®ã‚®ãƒ£ãƒƒãƒ—: -11
# é•·ã•5ã®ã‚®ãƒ£ãƒƒãƒ—: -14
# ï¼ˆç·šå½¢å¢—åŠ ã€æ€¥æ¿€ã§ã¯ãªã„ï¼‰
```

### 1-3. å›ºå®šãƒšãƒŠãƒ«ãƒ†ã‚£ã¨ã®æ¯”è¼ƒ

```
ã‚®ãƒ£ãƒƒãƒ—é•·  å›ºå®š(-2Ã—é•·ã•)  ã‚¢ãƒ•ã‚£ãƒ³(-10-1Ã—(é•·ã•-1))
    1          -2              -10
    2          -4              -11
    3          -6              -12
    5          -10             -14
    10         -20             -19

â†’ é•·ã„ã‚®ãƒ£ãƒƒãƒ—ãŒã‚ˆã‚Šè¨±å®¹ã•ã‚Œã‚‹ï¼
```

## ğŸ—ï¸ ã‚¹ãƒ†ãƒƒãƒ—2ï¼šã‚°ãƒ©ãƒ•ã¸ã®å®Ÿè£…ï¼ˆå˜ç´”ã ãŒéåŠ¹ç‡ï¼‰

### 2-1. ã‚¨ãƒƒã‚¸ã®è¿½åŠ 

```
å…ƒã®ã‚°ãƒ©ãƒ•ï¼š
â—‹â”€â”€â”€â—‹â”€â”€â”€â—‹
â”‚ â•² â”‚ â•² â”‚
â—‹â”€â”€â”€â—‹â”€â”€â”€â—‹
â”‚ â•² â”‚ â•² â”‚
â—‹â”€â”€â”€â—‹â”€â”€â”€â—‹

æ–°ã—ã„ã‚¨ãƒƒã‚¸ã‚’è¿½åŠ ï¼š
â—‹â•â•â•â—‹â•â•â•â—‹  ï¼ˆé•·ã•2ã®ã‚®ãƒ£ãƒƒãƒ—ï¼‰
â•‘ â•² â•‘ â•² â•‘
â—‹â•â•â•â—‹â•â•â•â—‹  ï¼ˆé•·ã•3ã®ã‚®ãƒ£ãƒƒãƒ—ï¼‰
â•‘ â•² â•‘ â•² â•‘
â—‹â•â•â•â—‹â•â•â•â—‹  ï¼ˆã™ã¹ã¦ã®é•·ã•ï¼‰
```

### 2-2. ã‚¨ãƒƒã‚¸æ•°ã®çˆ†ç™º

```python
# è¿½åŠ ã•ã‚Œã‚‹ã‚¨ãƒƒã‚¸æ•°
def count_new_edges(n, m):
    """nÃ—mã‚°ãƒªãƒƒãƒ‰ã§ã®æ–°ã—ã„ã‚¨ãƒƒã‚¸æ•°"""
    total = 0

    # æ°´å¹³æ–¹å‘ã®é•·ã„ã‚¨ãƒƒã‚¸
    for gap_length in range(2, m+1):
        total += n * (m - gap_length + 1)

    # å‚ç›´æ–¹å‘ã®é•·ã„ã‚¨ãƒƒã‚¸
    for gap_length in range(2, n+1):
        total += m * (n - gap_length + 1)

    return total
    # çµæœï¼šO(nÂ³)ã®ã‚¨ãƒƒã‚¸ï¼
```

### 2-3. è¨ˆç®—é‡ã®å•é¡Œ

```
æ™‚é–“è¨ˆç®—é‡ï¼šO(nÂ³)
ç©ºé–“è¨ˆç®—é‡ï¼šO(nÂ³)

â†’ å®Ÿç”¨çš„ã§ãªã„ï¼

10,000å¡©åŸºã®é…åˆ—ï¼š
1å…†å›ã®è¨ˆç®—ãŒå¿…è¦...
```

## ğŸ¨ ã‚¹ãƒ†ãƒƒãƒ—3ï¼š3å±¤ãƒãƒ³ãƒãƒƒã‚¿ãƒ³ã‚°ãƒªãƒƒãƒ‰ã®é­”æ³•

### 3-1. ãƒ¬ãƒ™ãƒ«ã®åˆ†é›¢

```
é©æ–°çš„ã‚¢ã‚¤ãƒ‡ã‚¢ï¼š
ã‚°ãƒ©ãƒ•ã‚’3ã¤ã®ãƒ¬ãƒ™ãƒ«ã«åˆ†é›¢ï¼

ä¸Šå±¤ï¼šå‰Šé™¤ã®ã¿ï¼ˆæ°´å¹³ç§»å‹•ï¼‰
    â—‹â”€â”€â”€â—‹â”€â”€â”€â—‹â”€â”€â”€â—‹

ä¸­å±¤ï¼šãƒãƒƒãƒ/ãƒŸã‚¹ãƒãƒƒãƒï¼ˆå¯¾è§’ç§»å‹•ï¼‰
    â—‹ â•² â—‹ â•² â—‹ â•² â—‹
      â•²   â•²   â•²

ä¸‹å±¤ï¼šæŒ¿å…¥ã®ã¿ï¼ˆå‚ç›´ç§»å‹•ï¼‰
    â—‹
    â”‚
    â—‹
    â”‚
    â—‹
```

### 3-2. ãƒ¬ãƒ™ãƒ«é–“ã®ç§»å‹•

```python
# ãƒ¬ãƒ™ãƒ«é–“ã®ç§»å‹•ãƒ«ãƒ¼ãƒ«
class ThreeLevelGraph:
    def transition_cost(from_level, to_level):
        if from_level == "middle" and to_level == "lower":
            return -Ïƒ  # ã‚®ãƒ£ãƒƒãƒ—é–‹å§‹ï¼ˆæŒ¿å…¥ï¼‰
        elif from_level == "lower" and to_level == "lower":
            return -Îµ  # ã‚®ãƒ£ãƒƒãƒ—ç¶™ç¶š
        elif from_level == "lower" and to_level == "middle":
            return 0   # ã‚®ãƒ£ãƒƒãƒ—çµ‚äº†
        # åŒæ§˜ã«ä¸Šå±¤ï¼ˆå‰Šé™¤ï¼‰ã‚‚å®šç¾©
```

### 3-3. ãªãœã“ã‚ŒãŒåŠ¹ç‡çš„ï¼Ÿ

```
å„ãƒãƒ¼ãƒ‰ã®æ¥ç¶šæ•°ï¼š
- å…ƒã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼šO(n)å€‹ã®éš£æ¥ãƒãƒ¼ãƒ‰
- 3å±¤ã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼šæœ€å¤§3å€‹ã®éš£æ¥ãƒãƒ¼ãƒ‰ï¼

ã‚¨ãƒƒã‚¸ç·æ•°ï¼š
- å…ƒï¼šO(nÂ³)
- æ–°ï¼šO(nÂ²)

åŠ‡çš„ãªæ”¹å–„ï¼
```

## ğŸ’» ã‚¹ãƒ†ãƒƒãƒ—4ï¼šå‹•çš„è¨ˆç”»æ³•ã®å®Ÿè£…

### 4-1. 3ã¤ã®å†å¸°å¼

```python
def affine_alignment(v, w, match_score, mismatch_score, Ïƒ, Îµ):
    """ã‚¢ãƒ•ã‚£ãƒ³ã‚®ãƒ£ãƒƒãƒ—ãƒšãƒŠãƒ«ãƒ†ã‚£ã‚’ä½¿ç”¨ã—ãŸã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆ"""
    m, n = len(v), len(w)

    # 3ã¤ã®ãƒ¬ãƒ™ãƒ«ã®ã‚¹ã‚³ã‚¢è¡Œåˆ—
    lower = [[float('-inf')] * (n+1) for _ in range(m+1)]   # æŒ¿å…¥
    middle = [[float('-inf')] * (n+1) for _ in range(m+1)]  # ãƒãƒƒãƒ
    upper = [[float('-inf')] * (n+1) for _ in range(m+1)]   # å‰Šé™¤

    # åˆæœŸåŒ–
    middle[0][0] = 0
```

### 4-2. æ›´æ–°è¦å‰‡

```python
    for i in range(1, m+1):
        for j in range(1, n+1):
            # ä¸‹å±¤ï¼ˆæŒ¿å…¥ï¼‰ã®æ›´æ–°
            lower[i][j] = max(
                lower[i-1][j] - Îµ,      # ã‚®ãƒ£ãƒƒãƒ—ç¶™ç¶š
                middle[i-1][j] - Ïƒ      # ã‚®ãƒ£ãƒƒãƒ—é–‹å§‹
            )

            # ä¸Šå±¤ï¼ˆå‰Šé™¤ï¼‰ã®æ›´æ–°
            upper[i][j] = max(
                upper[i][j-1] - Îµ,      # ã‚®ãƒ£ãƒƒãƒ—ç¶™ç¶š
                middle[i][j-1] - Ïƒ      # ã‚®ãƒ£ãƒƒãƒ—é–‹å§‹
            )

            # ä¸­å±¤ï¼ˆãƒãƒƒãƒ/ãƒŸã‚¹ãƒãƒƒãƒï¼‰ã®æ›´æ–°
            score = match_score if v[i-1] == w[j-1] else mismatch_score
            middle[i][j] = max(
                lower[i][j],            # æŒ¿å…¥ã‹ã‚‰æˆ»ã‚‹
                middle[i-1][j-1] + score,  # ãƒãƒƒãƒ/ãƒŸã‚¹ãƒãƒƒãƒ
                upper[i][j]             # å‰Šé™¤ã‹ã‚‰æˆ»ã‚‹
            )
```

### 4-3. ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°

```python
def backtrack_affine(lower, middle, upper, v, w):
    """3å±¤ã‚°ãƒ©ãƒ•ã§ã®ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°"""
    i, j = len(v), len(w)
    alignment = []
    current_level = "middle"  # çµ‚ç‚¹ã¯ä¸­å±¤

    while i > 0 or j > 0:
        if current_level == "middle":
            if i > 0 and j > 0 and middle[i][j] == middle[i-1][j-1] + score(v[i-1], w[j-1]):
                alignment.append((v[i-1], w[j-1]))
                i -= 1
                j -= 1
            elif middle[i][j] == lower[i][j]:
                current_level = "lower"
            else:
                current_level = "upper"

        elif current_level == "lower":
            alignment.append((v[i-1], '-'))
            i -= 1
            if lower[i][j] == middle[i][j] - Ïƒ:
                current_level = "middle"

        else:  # upper
            alignment.append(('-', w[j-1]))
            j -= 1
            if upper[i][j] == middle[i][j] - Ïƒ:
                current_level = "middle"

    return reversed(alignment)
```

## ğŸ§¬ ã‚¹ãƒ†ãƒƒãƒ—5ï¼šç”Ÿç‰©å­¦çš„å¿œç”¨

### 5-1. ã‚¿ãƒ³ãƒ‘ã‚¯è³ªé…åˆ—ã§ã®åˆ©ç”¨

```python
# å®Ÿéš›ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¾‹ï¼ˆBLOSUM62ï¼‰
def protein_alignment_params():
    return {
        'gap_open': -11,      # Ïƒ
        'gap_extend': -1,     # Îµ
        'matrix': 'BLOSUM62'
    }

# DNAã®å ´åˆ
def dna_alignment_params():
    return {
        'gap_open': -5,
        'gap_extend': -2,
        'match': +2,
        'mismatch': -3
    }
```

### 5-2. ã‚¤ãƒ³ãƒˆãƒ­ãƒ³ãƒ»ã‚¨ã‚¯ã‚½ãƒ³å¢ƒç•Œã®æ¤œå‡º

```
ã‚¨ã‚¯ã‚½ãƒ³é…åˆ—ã¨ã‚²ãƒãƒ é…åˆ—ã®ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆï¼š

ã‚²ãƒãƒ ï¼š  ATCG--------------------GCTA
         ã‚¨ã‚¯ã‚½ãƒ³1   ã‚¤ãƒ³ãƒˆãƒ­ãƒ³   ã‚¨ã‚¯ã‚½ãƒ³2

mRNAï¼š    ATCG                    GCTA
         ã‚¨ã‚¯ã‚½ãƒ³1              ã‚¨ã‚¯ã‚½ãƒ³2

ã‚¢ãƒ•ã‚£ãƒ³ã‚®ãƒ£ãƒƒãƒ— â†’ é•·ã„ã‚¤ãƒ³ãƒˆãƒ­ãƒ³ã‚’1ã¤ã®ã‚®ãƒ£ãƒƒãƒ—ã¨ã—ã¦æ‰±ãˆã‚‹
```

### 5-3. æ§‹é€ çš„å¤‰ç•°ã®æ¤œå‡º

```python
def detect_structural_variants(reference, sample):
    """æ§‹é€ çš„å¤‰ç•°ï¼ˆå¤§ããªæŒ¿å…¥/å‰Šé™¤ï¼‰ã‚’æ¤œå‡º"""
    alignment = affine_alignment(
        reference,
        sample,
        gap_open=-50,    # å¤§ããªãƒšãƒŠãƒ«ãƒ†ã‚£
        gap_extend=-0.5  # å°ã•ãªæ‹¡å¼µãƒšãƒŠãƒ«ãƒ†ã‚£
    )

    # é•·ã„ã‚®ãƒ£ãƒƒãƒ—ã‚’æ¢ã™
    gaps = find_long_gaps(alignment)
    return classify_variants(gaps)
```

## ğŸ¯ ã‚¹ãƒ†ãƒƒãƒ—6ï¼šãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ

### 6-1. è¨ˆç®—é‡ã®æ¯”è¼ƒ

```
ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ          æ™‚é–“è¨ˆç®—é‡  ç©ºé–“è¨ˆç®—é‡
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›ºå®šãƒšãƒŠãƒ«ãƒ†ã‚£      O(mn)      O(mn)
ãƒŠã‚¤ãƒ¼ãƒ–ã‚¢ãƒ•ã‚£ãƒ³    O(mnÂ²)     O(mnÂ²)
3å±¤ã‚°ãƒ©ãƒ•          O(mn)      O(mn)

â†’ 3å±¤ã‚°ãƒ©ãƒ•ãŒæœ€é©ï¼
```

### 6-2. å®Ÿè£…ã®æœ€é©åŒ–

```python
# ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–ç‰ˆï¼ˆHirschbergã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼‰
def memory_efficient_affine(v, w):
    """ç©ºé–“è¨ˆç®—é‡O(min(m,n))ã§ã®å®Ÿè£…"""
    # çŸ­ã„æ–¹ã®é…åˆ—ã‚’åˆ—ã«é…ç½®
    if len(v) > len(w):
        v, w = w, v

    # 2è¡Œåˆ†ã®ãƒ¡ãƒ¢ãƒªã®ã¿ä½¿ç”¨
    current_row = [0] * (len(w) + 1)
    previous_row = [0] * (len(w) + 1)

    # è©³ç´°ã¯çœç•¥...
```

### 6-3. ä¸¦åˆ—åŒ–ã®å¯èƒ½æ€§

```
ä¸¦åˆ—åŒ–æˆ¦ç•¥ï¼š
1. å¯¾è§’ç·šã«æ²¿ã£ãŸä¸¦åˆ—è¨ˆç®—
2. ãƒ–ãƒ­ãƒƒã‚¯åˆ†å‰²ã«ã‚ˆã‚‹ä¸¦åˆ—åŒ–
3. GPUã‚’ä½¿ç”¨ã—ãŸå¤§è¦æ¨¡ä¸¦åˆ—åŒ–

â†’ æ•°ä¸‡å¡©åŸºã®é…åˆ—ã‚‚å®Ÿç”¨çš„ã«ï¼
```

## ğŸ’¡ ã‚¹ãƒ†ãƒƒãƒ—7ï¼šã¾ã¨ã‚

### ãƒ¬ãƒ™ãƒ«1ï¼šåŸºç¤ç†è§£

```
å­¦ã‚“ã ã“ã¨ï¼š
1. é€£ç¶šã‚®ãƒ£ãƒƒãƒ— = å˜ä¸€ã®é€²åŒ–ã‚¤ãƒ™ãƒ³ãƒˆ
2. ã‚¢ãƒ•ã‚£ãƒ³ãƒšãƒŠãƒ«ãƒ†ã‚£ = ã‚ˆã‚Šç¾å®Ÿçš„
3. 3å±¤ã‚°ãƒ©ãƒ• = åŠ¹ç‡çš„ãªå®Ÿè£…
```

### ãƒ¬ãƒ™ãƒ«2ï¼šå¿œç”¨ç†è§£

```
ã§ãã‚‹ã‚ˆã†ã«ãªã£ãŸã“ã¨ï¼š
1. ç”Ÿç‰©å­¦çš„ã«å¦¥å½“ãªã‚®ãƒ£ãƒƒãƒ—ãƒšãƒŠãƒ«ãƒ†ã‚£è¨­å®š
2. é•·ã„ã‚¤ãƒ³ãƒ‡ãƒ«ã®é©åˆ‡ãªæ‰±ã„
3. æ§‹é€ çš„å¤‰ç•°ã®æ¤œå‡º
```

### ãƒ¬ãƒ™ãƒ«3ï¼šå®Ÿè£…ç†è§£

```python
# å®Œå…¨ãªå®Ÿè£…
class AffineAligner:
    def __init__(self, match=2, mismatch=-3, gap_open=-5, gap_extend=-2):
        self.match = match
        self.mismatch = mismatch
        self.gap_open = gap_open
        self.gap_extend = gap_extend

    def align(self, seq1, seq2):
        """ã‚¢ãƒ•ã‚£ãƒ³ã‚®ãƒ£ãƒƒãƒ—ãƒšãƒŠãƒ«ãƒ†ã‚£ã‚’ä½¿ç”¨ã—ãŸé…åˆ—ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆ"""
        m, n = len(seq1), len(seq2)

        # 3å±¤ã®å‹•çš„è¨ˆç”»æ³•ãƒ†ãƒ¼ãƒ–ãƒ«
        M = self._init_matrix(m, n)  # ãƒãƒƒãƒ/ãƒŸã‚¹ãƒãƒƒãƒ
        I = self._init_matrix(m, n)  # æŒ¿å…¥
        D = self._init_matrix(m, n)  # å‰Šé™¤

        # å¢ƒç•Œæ¡ä»¶ã®è¨­å®š
        self._set_boundaries(M, I, D, m, n)

        # å‹•çš„è¨ˆç”»æ³•ã®å®Ÿè¡Œ
        self._fill_matrices(M, I, D, seq1, seq2)

        # ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°
        alignment = self._backtrack(M, I, D, seq1, seq2)

        return alignment

    def _fill_matrices(self, M, I, D, seq1, seq2):
        """3ã¤ã®è¡Œåˆ—ã‚’åŸ‹ã‚ã‚‹"""
        for i in range(1, len(seq1) + 1):
            for j in range(1, len(seq2) + 1):
                # æŒ¿å…¥è¡Œåˆ—
                I[i][j] = max(
                    M[i-1][j] + self.gap_open,
                    I[i-1][j] + self.gap_extend
                )

                # å‰Šé™¤è¡Œåˆ—
                D[i][j] = max(
                    M[i][j-1] + self.gap_open,
                    D[i][j-1] + self.gap_extend
                )

                # ãƒãƒƒãƒ/ãƒŸã‚¹ãƒãƒƒãƒè¡Œåˆ—
                match_score = self.match if seq1[i-1] == seq2[j-1] else self.mismatch
                M[i][j] = max(
                    M[i-1][j-1] + match_score,
                    I[i][j],
                    D[i][j]
                )
```

## ğŸš€ æ¬¡å›äºˆå‘Š

æ¬¡å›ã¯ã€Œè¤‡æ•°é…åˆ—ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆã€ã«ã¤ã„ã¦å­¦ã³ã¾ã™ã€‚2ã¤ã§ã¯ãªãã€ä½•åã‚‚ã®é…åˆ—ã‚’åŒæ™‚ã«æ¯”è¼ƒã™ã‚‹ã«ã¯ï¼Ÿã€€é€²åŒ–ç³»çµ±æ¨¹ã®æ§‹ç¯‰ã¸ã®ç¬¬ä¸€æ­©ã‚’è¸ã¿å‡ºã—ã¾ã™ï¼

---

_ã‚ˆã‚Šç¾å®Ÿçš„ãªé…åˆ—æ¯”è¼ƒã¸ã€ä¸€æ­©å‰é€²ã—ã¾ã—ãŸï¼_
