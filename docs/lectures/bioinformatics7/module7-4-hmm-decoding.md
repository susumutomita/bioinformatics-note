# HMMデコード問題：マンハッタングラフで隠れ経路を解き明かす（超詳細版）

## 🎯 まず、この講義で何を学ぶのか

最終ゴール：**観察されたシンボル列から、最も可能性の高い隠れ状態列を見つける「デコード問題」を、マンハッタングラフを使って解く方法を完全理解する**

でも、ちょっと待ってください。なぜマンハッタングラフがまた出てくるの。
実は、**HMMの経路探索問題は、重み付きグラフの最適経路問題に帰着できる**という驚きの事実があるんです。

## 🤔 ステップ0：デコード問題って何を解くの

### 0-1. そもそもの問題設定

```
観察されたもの：HHTHHTHHTT（コイン投げ結果）
知りたいもの：FFFBBBFFFF（どのコインを使ったか）

でも無数の可能性がある：
- FFFFFFFFFF（ずっとフェア）
- BBBBBBBBBB（ずっとバイアス）
- FFBBFFBBFF（交互に切り替え）
- ...（2^10 = 1024通り）
```

### 0-2. デコード問題の正式な定義

```python
def decoding_problem():
    """
    入力：
    - X：観察されたシンボル列
    - HMM：（アルファベット、状態、遷移確率、放出確率）

    出力：
    - π：P(X, π)を最大化する隠れ経路
    """
    return optimal_hidden_path
```

## 📖 ステップ1：なぜマンハッタングラフなのか

### 1-1. 前に見たマンハッタングラフ

```
配列アラインメント問題：
    A T G C
  T □─□─□─□
  A □─□─□─□
  G □─□─□─□

各パス = 一つのアラインメント
```

### 1-2. HMMもグラフで表現できる

```
HMMのデコード：
時刻: 0   1   2   3   4
  F: ○───○───○───○───○
     │ ╲ │ ╲ │ ╲ │ ╲ │
  B: ○───○───○───○───○

各パス = 一つの隠れ経路
```

**天才的アイデア**：HMMの状態遷移をグラフの経路として表現。

## 📖 ステップ2：HMMマンハッタングラフの構築

### 2-1. グラフの基本構造

```python
def build_hmm_manhattan_graph(n_symbols, n_states):
    """
    n_symbols: 観察されたシンボルの数（列数）
    n_states: HMMの状態数（行数）
    """
    # 例：10個のコイン投げ、2状態（F, B）
    # → 2行10列のグラフ

    graph = Grid(rows=n_states, cols=n_symbols)
    return graph
```

### 2-2. 具体例で見てみよう

```
X = "HHTHHT"（6回のコイン投げ）

   start  H    H    T    H    H    T   end
     ○────○────○────○────○────○────○────○
      ╲  ╱ ╲  ╱ ╲  ╱ ╲  ╱ ╲  ╱ ╲  ╱ ╲  ╱
     ○────○────○────○────○────○────○────○

上の行：Fair状態
下の行：Biased状態
```

## 📖 ステップ3：エッジへの重み付け（ここが核心）

### 3-1. エッジが表すもの

各エッジは2つの事象を表す：

1. **状態遷移**：前の状態から次の状態へ
2. **シンボル放出**：その状態からシンボルを出す

### 3-2. 重みの計算式

```python
def edge_weight(from_state, to_state, symbol):
    """
    エッジの重み = 遷移確率 × 放出確率
    """
    transition = P(from_state → to_state)
    emission = P(symbol | to_state)

    weight = transition * emission
    return weight
```

## 📖 ステップ4：具体的な重み計算

### 4-1. 例：FからBへ、Hを放出

```
状況：Fair状態からBiased状態へ移り、Hを観察

計算：
- 遷移確率：P(F→B) = 0.1
- 放出確率：P(H|B) = 0.75

エッジの重み = 0.1 × 0.75 = 0.075
```

### 4-2. すべてのエッジの重み表

```python
# 時刻iでシンボルX[i]を観察したときの重み
weights = {
    ("F", "F", "H"): 0.9 * 0.5,   # = 0.45
    ("F", "F", "T"): 0.9 * 0.5,   # = 0.45
    ("F", "B", "H"): 0.1 * 0.75,  # = 0.075
    ("F", "B", "T"): 0.1 * 0.25,  # = 0.025
    ("B", "F", "H"): 0.1 * 0.5,   # = 0.05
    ("B", "F", "T"): 0.1 * 0.5,   # = 0.05
    ("B", "B", "H"): 0.9 * 0.75,  # = 0.675
    ("B", "B", "T"): 0.9 * 0.25,  # = 0.225
}
```

## 📖 ステップ5：経路の積重みとは

### 5-1. 経路全体の確率

```python
def path_probability(X, π):
    """
    経路の確率 = すべてのエッジの重みの積
    """
    prob = initial_probability(π[0])

    for i in range(len(X)):
        # 各ステップの重み
        edge_prob = edge_weight(π[i-1], π[i], X[i])
        prob *= edge_prob

    return prob
```

### 5-2. 実例で計算

```
X = "HHT"
π = "FFB"

初期：P(F) = 0.5
エッジ1：F→F, H放出 = 0.45
エッジ2：F→F, H放出 = 0.45
エッジ3：F→B, T放出 = 0.025

全体 = 0.5 × 0.45 × 0.45 × 0.025 = 0.00253125
```

## 📖 ステップ6：なぜ「積」の重みなのか

### 6-1. 確率の連鎖法則

```
独立事象の同時確率 = 個別確率の積

例：
P(コイン1が表 AND コイン2が表)
= P(コイン1が表) × P(コイン2が表)
= 0.5 × 0.5 = 0.25
```

### 6-2. HMMでの応用

```
P(経路全体) = P(初期状態)
            × P(遷移1) × P(放出1)
            × P(遷移2) × P(放出2)
            × ...
```

## 📖 ステップ7：最適経路を見つける

### 7-1. 全探索は現実的でない

```python
def brute_force_decoding(X, hmm):
    """素朴な方法：すべての経路を試す"""
    n = len(X)
    k = len(hmm.states)

    all_paths = k ** n  # 例：2^100 ≈ 10^30

    # 現実的に計算不可能。
    return "無理。"
```

### 7-2. でも希望はある

```
重要な観察：
このグラフは「有向非環グラフ（DAG）」

つまり：
- 後戻りがない
- 動的計画法が使える
→ Viterbiアルゴリズム（次回）
```

## 📖 ステップ8：マンハッタングラフの威力

### 8-1. 視覚的理解

```
最適経路を見つける = グラフ上の最大積経路

   ○────○────○────○
    ╲  ╱ ╲  ╱ ╲  ╱
   ○────○────○────○

太線：最適経路
細線：その他の経路
```

### 8-2. なぜこの変換が画期的か

```python
# 元の問題
def hmm_decoding():
    """確率モデルの最適化問題"""
    # 複雑な確率計算
    pass

# 変換後
def graph_problem():
    """グラフの経路探索問題"""
    # よく知られた問題。
    pass
```

## 📖 ステップ9：より複雑なHMMの場合

### 9-1. 3状態以上のHMM

```
3状態（A, B, C）の場合：

   start  X₁   X₂   X₃  end
A:   ○────○────○────○────○
      ╲  ╱ ╲  ╱ ╲  ╱ ╲  ╱
B:   ○────○────○────○────○
      ╲  ╱ ╲  ╱ ╲  ╱ ╲  ╱
C:   ○────○────○────○────○

各列で9本のエッジ（3×3）
```

### 9-2. 一般化

```python
def general_hmm_graph(k_states, n_symbols):
    """
    k状態、n個のシンボル
    """
    nodes = k_states * n_symbols
    edges = k_states * k_states * (n_symbols - 1)

    # k=10, n=100の場合
    # ノード数：1000
    # エッジ数：9900
    # 可能な経路数：10^100（それでも巨大）
```

## 📖 ステップ10：次への布石

### 10-1. 現時点での成果

```
達成したこと：
1. HMM問題をグラフ問題に変換
2. エッジの重み付け方法を確立
3. 最適経路 = 最大積経路と判明

残る課題：
効率的に最大積経路を見つける方法
```

### 10-2. Viterbiアルゴリズムへ

```python
def viterbi_preview():
    """次回の予告"""
    # 動的計画法を使えば...
    # O(k²n)で解ける。
    # k^nからk²nへの劇的な改善。
```

## 🎓 まとめ：今日学んだことを整理

### レベル1：表面的理解（これだけでもOK）

- デコード問題は最も可能性の高い隠れ経路を見つける問題
- HMMをマンハッタングラフに変換できる
- エッジの重み = 遷移確率 × 放出確率

### レベル2：本質的理解（ここまで来たら素晴らしい）

- 経路の確率 = エッジの重みの積
- HMMの状態遷移がグラフの経路に対応
- 最適経路探索は重み付きグラフ問題に帰着

### レベル3：応用的理解（プロレベル）

- 有向非環グラフ（DAG）の性質が動的計画法を可能にする
- 積の最大化問題は対数変換で和の最大化に変換可能
- k状態n記号の一般化により任意のHMMに適用可能

## 🚀 次回予告

次回は、ついに**Viterbiアルゴリズム**の詳細実装。
「なぜO(k²n)で最適経路が見つかるのか」
「動的計画法の再帰式はどう導出されるのか」
その驚異的な効率性の秘密が明らかに。

## 📚 重要な概念

1. **デコード問題**：観察列Xから最適な隠れ経路πを見つける
2. **マンハッタングラフ**：HMMの状態遷移を表現する格子グラフ
3. **エッジ重み**：遷移確率と放出確率の積
4. **積重み**：経路全体の確率（エッジ重みの積）
5. **有向非環グラフ（DAG）**：サイクルのない有向グラフ

## 🔬 実験：グラフ構築シミュレーター

```python
import numpy as np

class HMMGraphBuilder:
    """HMMマンハッタングラフ構築"""

    def __init__(self, states, symbols):
        self.states = states
        self.symbols = symbols
        self.graph = {}

    def add_edge(self, t, from_state, to_state, symbol):
        """時刻tでのエッジ追加"""
        # 遷移確率と放出確率から重み計算
        trans_prob = self.get_transition(from_state, to_state)
        emit_prob = self.get_emission(to_state, symbol)

        weight = trans_prob * emit_prob

        # グラフに追加
        self.graph[(t, from_state, to_state)] = weight

    def find_best_path(self):
        """最適経路を見つける（次回詳細）"""
        # Viterbiアルゴリズムで実装
        pass

# 使用例
builder = HMMGraphBuilder(
    states=["Fair", "Biased"],
    symbols="HHTHHT"
)
```

---

### 次回：「Viterbiアルゴリズム - 動的計画法がHMMデコードを征服する」
